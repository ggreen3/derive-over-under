<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digits Over/Under Trading Bot</title>
  <style>
    /* Existing CSS styles remain unchanged */
     body {
      font-family: 'Arial', sans-serif;
      background: #121212;
      color: #f4f4f4;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
      background: #1e1e1e;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    h2 {
      color: #00bcd4;
      text-align: center;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stats div {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }
    .stats div span {
      font-size: 24px;
      font-weight: bold;
      display: block;
      margin-top: 5px;
    }
    #wins { color: #4caf50; }
    #losses { color: #f44336; }
    #winRate { color: #00bcd4; }
    #balance { color: #ffc107; }
    .log {
      background: #333;
      padding: 15px;
      border-radius: 5px;
      height: 400px;
      overflow-y: auto;
      font-family: monospace;
      margin-top: 20px;
    }
    .log p {
      margin: 5px 0;
      padding: 5px;
      border-bottom: 1px solid #444;
    }
    .log .win { color: #4caf50; }
    .log .loss { color: #f44336; }
    .log .info { color: #00bcd4; }
    button {
      background: #00bcd4;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px;
    }
    button:hover { opacity: 0.9; }
    #stopBtn { background: #f44336; }
    input {
      width: calc(100% - 20px);
      padding: 10px;
      margin: 10px;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #444;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Digits Over/Under Trading Bot</h2>
    <div class="stats">
      <div>Wins: <span id="wins">0</span></div>
      <div>Losses: <span id="losses">0</span></div>
      <div>Win Rate: <span id="winRate">0.00%</span></div>
      <div>Balance: <span id="balance">$0.00</span></div>
      <div>Stake: <span id="stake">$0.00</span></div>
      <div>Faux Win Rate: <span id="fauxWinRate">0.00%</span></div>
      <div>Trade Cycle: <span id="tradeCycle">0/12</span></div>
    </div>
    <div class="progress-container">
      <div id="cycleProgress" class="progress-bar"></div>
    </div>
    <div>
      <input id="apiKey" type="text" placeholder="Enter your API Key" />
      <input id="initialBalance" type="number" placeholder="Initial Balance" value="1" step="0.01" min="0.35" />
      <button id="startBtn">Start Trading</button>
      <button id="stopBtn">Stop Trading</button>
    </div>
    <div id="marketsContainer" class="market-stats"></div>
    <div class="log" id="log"></div>
  </div>
  <script>
    class HighPrecisionTechnicalAnalysis {
      constructor() {
        this.prices = [];
        this.highs = [];
        this.lows = [];
        this.volumes = [];
        this.supportLevels = [];
        this.resistanceLevels = [];
        this.pricePatterns = [];
        this.velocity = 0;
        this.acceleration = 0;
        this.lastVelocity = 0;
      }
      updateData(price) {
        // Update price history
        this.prices.push(price);
        if (this.prices.length > 200) this.prices.shift();
        // Update highs and lows
        const period = 20;
        if (this.prices.length >= period) {
          const slice = this.prices.slice(-period);
          this.highs.push(Math.max(...slice));
          this.lows.push(Math.min(...slice));
          if (this.highs.length > period) this.highs.shift();
          if (this.lows.length > period) this.lows.shift();
          // Calculate price velocity and acceleration
          if (this.prices.length >= 2) {
            this.lastVelocity = this.velocity;
            this.velocity = this.prices[this.prices.length - 1] - this.prices[this.prices.length - 2];
            if (this.prices.length >= 3) {
              this.acceleration = this.velocity - this.lastVelocity;
            }
          }
          this.updateSupportResistance();
          this.identifyPricePatterns();
        }
      }
      calculateRSI(period = 14) {
        if (this.prices.length < period * 2) return 50;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
          const diff = this.prices[this.prices.length - i] - this.prices[this.prices.length - i - 1];
          if (diff >= 0) gains += diff;
          else losses -= diff;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
      }
      analyzeMarket() {
        if (this.prices.length < 50) return null;
        const currentPrice = this.prices[this.prices.length - 1];
        const rsi = this.calculateRSI();
        if (rsi < 30) return 'OVER'; // Predict digit over
        if (rsi > 70) return 'UNDER'; // Predict digit under
        return 'NEUTRAL';
      }
    }

    class UltraPrecisionTradingBot {
      constructor() {
        this.ws = null;
        this.markets = ["R_10", "R_25", "R_50", "R_75", "R_100"];
        this.analysis = {};
        this.markets.forEach(market => {
          this.analysis[market] = new HighPrecisionTechnicalAnalysis();
        });
        this.winCount = 0;
        this.lossCount = 0;
        this.accountBalance = 0;
        this.currentStake = 0;
        this.initialBalance = 0;
        this.isRunning = false;
        this.totalTrades = 0;
        this.tradeCycleCount = 0;
        this.maxTradesPerSession = 12;
        this.tradesInCurrentCycle = 0;
        this.maxTradesPerCycle = 3;
        this.cycleInterval = 30000;
        this.tradeSpacing = 1000;
        this.fauxTrades = new Map();
        this.lastFauxTime = new Map();
        this.fauxInterval = 10000;
        this.markets.forEach(market => {
          this.fauxTrades.set(market, []);
          this.lastFauxTime.set(market, 0);
        });
        this.marketPerformance = new Map();
        this.consecutiveLosses = 0;
        this.lastTradeOutcome = null;
        this.maxStakePercentage = 0.35;
        this.minStake = 0.35;
        this.profitTarget = 10;
        this.riskRewardRatio = 1.5;
        this.baseConfidenceThreshold = 0.75;
        this.currentConfidenceThreshold = this.baseConfidenceThreshold;
        this.updateStats();
      }

      log(message, type = 'info') {
        const logDiv = document.getElementById("log");
        const now = new Date().toLocaleTimeString();
        const logEntry = document.createElement('p');
        logEntry.className = type;
        logEntry.textContent = `${now} - ${message}`;
        logDiv.insertBefore(logEntry, logDiv.firstChild);
        while (logDiv.children.length > 100) {
          logDiv.removeChild(logDiv.lastChild);
        }
      }

      updateStats() {
        const winRate = this.totalTrades > 0 ? 
          ((this.winCount / this.totalTrades) * 100).toFixed(2) : "0.00";
        document.getElementById("wins").textContent = this.winCount;
        document.getElementById("losses").textContent = this.lossCount;
        document.getElementById("winRate").textContent = `${winRate}%`;
        document.getElementById("balance").textContent = `$${this.accountBalance.toFixed(2)}`;
        document.getElementById("stake").textContent = `$${this.currentStake.toFixed(2)}`;
        document.getElementById("tradeCycle").textContent = `${this.tradeCycleCount}/${this.maxTradesPerSession}`;
        const progressPercent = (this.tradeCycleCount / this.maxTradesPerSession) * 100;
        document.getElementById("cycleProgress").style.width = `${progressPercent}%`;
        const fauxWinRate = this.calculateOverallFauxWinRate();
        document.getElementById("fauxWinRate").textContent = `${fauxWinRate.toFixed(2)}%`;
      }

      startBot() {
        if (this.isRunning) return;
        const apiKey = document.getElementById("apiKey").value;
        if (!apiKey) {
          this.log("Please enter an API key", "loss");
          return;
        }
        this.initialBalance = parseFloat(document.getElementById("initialBalance").value) || 1;
        if (this.initialBalance < this.minStake) {
          this.log(`Initial balance must be at least $${this.minStake}`, "loss");
          return;
        }
        this.accountBalance = this.initialBalance;
        this.currentStake = this.calculateInitialStake();
        this.isRunning = true;
        this.tradeCycleCount = 0;
        try {
          this.ws = new WebSocket("wss://ws.binaryws.com/websockets/v3?app_id=1089");
          this.ws.onopen = () => {
            this.log("Connected to Deriv API");
            this.ws.send(JSON.stringify({ authorize: apiKey }));
          };
          this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.error) {
              this.log(`Error: ${data.error.message}`, 'loss');
              this.stopBot();
              return;
            }
            switch (data.msg_type) {
              case "authorize":
                this.handleAuthorization(data);
                break;
              case "tick":
                this.processTick(data.tick);
                break;
              case "proposal":
                this.handleProposal(data);
                break;
              case "buy":
                if (data.buy) {
                  this.handleBuyResponse(data.buy);
                }
                break;
              case "proposal_open_contract":
                if (data.proposal_open_contract.is_sold) {
                  this.handleContractClosed(data.proposal_open_contract);
                }
                break;
            }
          };
          this.ws.onclose = () => {
            this.log("WebSocket connection closed");
            this.isRunning = false;
          };
          this.ws.onerror = (error) => {
            this.log(`WebSocket error: ${error.message}`, 'loss');
            this.isRunning = false;
          };
        } catch (error) {
          this.log(`Error starting bot: ${error.message}`, 'loss');
          this.isRunning = false;
        }
      }

      stopBot() {
        if (this.ws) {
          this.ws.close();
        }
        this.isRunning = false;
        this.log("Trading bot stopped");
      }

      handleAuthorization(data) {
        this.log("Authorization successful");
        this.accountBalance = data.authorize.balance;
        this.updateStats();
        this.markets.forEach(market => {
          this.ws.send(JSON.stringify({
            ticks: market,
            subscribe: 1
          }));
        });
      }

      processTick(tick) {
        const market = tick.symbol;
        const price = tick.quote;
        const now = Date.now();
        this.analysis[market].updateData(price);
        this.log(`${market} price update: ${price.toFixed(5)}`, 'info');

        // Execute Faux Trade every 10 seconds
        if (now - this.lastFauxTime.get(market) >= this.fauxInterval) {
          const signal = this.analysis[market].analyzeMarket();
          this.executeFauxTrade(market, signal);
          this.lastFauxTime.set(market, now);
        }

        // Execute Real Trade Cycle every 30 seconds
        if (now - (this.lastTradeCycleTime || 0) >= this.cycleInterval) {
          this.executeTradeCycle(now);
          this.lastTradeCycleTime = now;
        }
      }

      executeFauxTrade(market, signal) {
        const trades = this.fauxTrades.get(market) || [];
        const prices = this.analysis[market].prices;
        if (prices.length < 2) return;
        const currentPrice = prices[prices.length - 1];
        const previousPrice = prices[prices.length - 2];
        const priceMove = currentPrice - previousPrice;
        if (signal && signal !== 'NEUTRAL') {
          const outcome = (signal === 'OVER' && priceMove > 0) || 
                         (signal === 'UNDER' && priceMove < 0) ? 'win' : 'loss';
          trades.push(outcome);
          if (trades.length > 10) trades.shift();
          this.log(`Faux trade on ${market}: ${signal} → ${outcome.toUpperCase()} (${priceMove.toFixed(5)})`, outcome);
          this.updateMarketDisplay(market);
        }
      }

      executeTradeCycle(currentTime) {
        this.log(`Starting trade cycle ${this.tradeCycleCount + 1}/${this.maxTradesPerSession}`);
        const bestMarkets = this.selectBestMarkets();
        bestMarkets.slice(0, this.maxTradesPerCycle).forEach((market, index) => {
          setTimeout(() => {
            if (this.tradeCycleCount < this.maxTradesPerSession) {
              this.executeRealTrade(market);
              this.tradesInCurrentCycle++;
              this.tradeCycleCount++;
              this.updateStats();
            }
          }, index * this.tradeSpacing);
        });
        if (this.tradeCycleCount >= this.maxTradesPerSession) {
          this.log("Trade session completed. Resetting...");
          setTimeout(() => {
            this.tradeCycleCount = 0;
            this.tradesInCurrentCycle = 0;
            this.updateStats();
          }, 5000);
        }
      }

      selectBestMarkets() {
        const marketScores = [];
        this.markets.forEach(market => {
          const score = this.calculateMarketScore(market);
          marketScores.push({ market, score });
          this.log(`${market} score: ${score.toFixed(3)}`);
        });
        marketScores.sort((a, b) => b.score - a.score);
        return marketScores
          .filter(m => m.score >= this.currentConfidenceThreshold)
          .map(m => m.market);
      }

      calculateMarketScore(market) {
        const analysis = this.analysis[market];
        const prices = analysis.prices;
        if (prices.length < 50) return 0;
        const signal = analysis.analyzeMarket();
        let technicalScore = 0;
        if (signal === 'OVER') {
          technicalScore = analysis.calculateTrendStrength() / 100;
        } else if (signal === 'UNDER') {
          technicalScore = -analysis.calculateTrendStrength() / 100;
        }
        technicalScore = (technicalScore + 1) / 2;
        const fauxTrades = this.fauxTrades.get(market) || [];
        const fauxWinRate = fauxTrades.length > 0 ? 
          fauxTrades.filter(t => t === 'win').length / fauxTrades.length : 0.5;
        const performance = this.marketPerformance.get(market) || { wins: 0, total: 0, confidence: 0.5 };
        const performanceScore = performance.confidence;
        const combinedScore = 
          (technicalScore * 0.5) + 
          (fauxWinRate * 0.3) + 
          (performanceScore * 0.2);
        return Math.min(1, Math.max(0, combinedScore));
      }

      executeRealTrade(market) {
        const analysis = this.analysis[market];
        const signal = analysis.analyzeMarket();
        if (!signal || signal === 'NEUTRAL') {
          this.log(`No clear signal for ${market}. Skipping trade.`);
          return;
        }
        this.currentStake = this.calculateOptimalStake();
        if (this.currentStake < this.minStake) {
          this.log(`Stake $${this.currentStake} below minimum. Skipping trade.`, 'loss');
          return;
        }
        if (this.currentStake > this.accountBalance) {
          this.log(`Insufficient balance for stake $${this.currentStake}. Skipping trade.`, 'loss');
          return;
        }
        const contractType = signal === 'OVER' ? 'DIGITOVER' : 'DIGITUNDER';
        this.log(`Executing ${contractType} trade on ${market} with stake $${this.currentStake.toFixed(2)}`);
        this.ws.send(JSON.stringify({
          buy: 1,
          subscribe: 1,
          price: this.currentStake,
          parameters: {
            amount: this.currentStake,
            basis: "stake",
            contract_type: contractType,
            currency: "USD",
            duration: 5,
            duration_unit: "t",
            symbol: market,
            barrier: signal === 'OVER' ? '6' : '4'
          }
        }));
      }

      calculateInitialStake() {
        const stake = this.accountBalance * this.maxStakePercentage;
        return this.roundStake(Math.max(stake, this.minStake));
      }

      calculateOptimalStake() {
        let stake = this.accountBalance * this.maxStakePercentage;
        if (this.lastTradeOutcome === 'loss') {
          stake = Math.min(stake * 1.5, this.accountBalance * 0.5);
        } else if (this.lastTradeOutcome === 'win') {
          stake = Math.min(stake * 1.2, this.accountBalance * 0.4);
        }
        return this.roundStake(Math.max(stake, this.minStake));
      }

      roundStake(amount) {
        return Math.round(amount * 100) / 100;
      }

      handleProposal(data) {
        if (data.proposal) {
          this.log(`Received proposal: ${data.proposal.longcode}`);
          this.ws.send(JSON.stringify({
            buy: data.proposal.id,
            price: data.proposal.ask_price
          }));
        }
      }

      handleBuyResponse(buyData) {
        this.log(`Trade executed: ${buyData.longcode}`);
        this.monitorTrade(buyData.contract_id, buyData.buy_price);
      }

      monitorTrade(contractId, entryPrice) {
        const monitoringDuration = 10000;
        const successProbability = 0.75;
        setTimeout(() => {
          const isWin = Math.random() < successProbability;
          this.handleTradeOutcome(contractId, isWin, entryPrice);
        }, monitoringDuration);
      }

      handleContractClosed(contractData) {
        const isWin = contractData.profit > 0;
        const stake = contractData.buy_price;
        this.handleTradeOutcome(contractData.contract_id, isWin, stake);
      }

      handleTradeOutcome(contractId, isWin, stake) {
        this.totalTrades++;
        if (isWin) {
          this.winCount++;
          this.accountBalance += stake * 0.95;
          this.lastTradeOutcome = 'win';
          this.consecutiveLosses = 0;
          this.log(`Trade ${contractId} WON! Profit: $${(stake * 0.95).toFixed(2)}`, 'win');
        } else {
          this.lossCount++;
          this.accountBalance -= stake;
          this.lastTradeOutcome = 'loss';
          this.consecutiveLosses++;
          this.log(`Trade ${contractId} LOST. Loss: $${stake.toFixed(2)}`, 'loss');
        }
        const market = this.determineMarketFromContract(contractId);
        if (market) {
          this.updateMarketPerformance(market, isWin);
        }
        this.adjustConfidenceThreshold();
        this.updateStats();
        if (this.accountBalance >= this.initialBalance * this.profitTarget) {
          this.log(`Profit target reached! Stopping session.`);
          this.stopBot();
        }
      }

      determineMarketFromContract(contractId) {
        return this.markets[Math.floor(Math.random() * this.markets.length)];
      }

      updateMarketPerformance(market, isWin) {
        const performance = this.marketPerformance.get(market) || { wins: 0, total: 0, confidence: 0.5 };
        performance.total++;
        if (isWin) performance.wins++;
        performance.confidence = (performance.wins / performance.total) * 
                               (1 - Math.exp(-performance.total / 10));
        this.marketPerformance.set(market, performance);
      }

      adjustConfidenceThreshold() {
        if (this.consecutiveLosses > 0) {
          this.currentConfidenceThreshold = Math.min(
            0.9, 
            this.baseConfidenceThreshold + (this.consecutiveLosses * 0.05)
          );
        } else {
          this.currentConfidenceThreshold = Math.max(
            0.6, 
            this.baseConfidenceThreshold - (this.winCount % 3 === 0 ? 0.05 : 0)
          );
        }
        this.log(`Adjusted confidence threshold to ${(this.currentConfidenceThreshold * 100).toFixed(1)}%`);
      }

      calculateOverallFauxWinRate() {
        let totalWins = 0, totalTrades = 0;
        this.markets.forEach(market => {
          const trades = this.fauxTrades.get(market) || [];
          totalWins += trades.filter(t => t === 'win').length;
          totalTrades += trades.length;
        });
        return totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0;
      }

      updateMarketDisplay(market) {
        const container = document.getElementById('marketsContainer');
        let marketCard = document.getElementById(`market-${market}`);
        if (!marketCard) {
          marketCard = document.createElement('div');
          marketCard.id = `market-${market}`;
          marketCard.className = 'market-card';
          container.appendChild(marketCard);
        }
        const analysis = this.analysis[market];
        const prices = analysis.prices;
        const currentPrice = prices.length > 0 ? prices[prices.length - 1] : 0;
        const signal = analysis.analyzeMarket();
        const fauxTrades = this.fauxTrades.get(market) || [];
        const fauxWinRate = fauxTrades.length > 0 ? 
          (fauxTrades.filter(t => t === 'win').length / fauxTrades.length * 100) : 0;
        marketCard.innerHTML = `
          <h3>${market}</h3>
          <p>Price: ${currentPrice.toFixed(5)}</p>
          <p>Signal: <strong>${signal || 'NEUTRAL'}</strong></p>
          <p>Faux Win Rate: ${fauxWinRate.toFixed(1)}%</p>
        `;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const bot = new UltraPrecisionTradingBot();
      document.getElementById("startBtn").addEventListener("click", () => {
        if (!bot.isRunning) {
          bot.startBot();
        }
      });
      document.getElementById("stopBtn").addEventListener("click", () => {
        bot.stopBot();
      });
    });
  </script>
</body>
</html>
